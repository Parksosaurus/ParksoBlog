---
author: parkso
title: Redis持久化机制
categories:
  - CS技术
slug: redis-persistence-mechanism-zqmfur
url: /post/redis-persistence-mechanism-zqmfur.html
date: '2023-01-16 14:40:51+08:00'
lastmod: '2024-05-01 16:43:31+08:00'
toc: true
isCJKLanguage: true
---

# Redis持久化机制

‍

Redis因为是基于内存的数据库，所以需要进行数据的持久化。

Redis通过**RDB快照**和**AOF日志**来实现数据的持久化

这两种技术都会各用一个日志文件来记录信息，但是记录的内容是不同的

* RDB文件的内容是redis保存的键值对转化成的二进制数据
* AOF文件的内容是操作命令

# RDB持久化

## RDB文件的创建和载入

‍

### RDB文件的创建

Redis提供了两个命令来生成RDB文件，一个是`SAVE`​，一个是`BGSAVE`​ 。

* `SAVE`​命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求
* ​`BGSAVE`命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程(父进程)继续处理请求命令

创建RDB文件的实际工作是由`rdb.c/rdbSave`​函数完成

```c
def SAVE():
    #创建RDB文件
    rdbSave()
def BGSAVE():
    #创建子进程
    pid = fork()
    if pid == 0:
        #子进程负责创建RDB文件
        rdbSave()
        #完成之后向父进程发送信号
        signal_parent()
    elif pid ＞ 0:
        #父进程继续处理命令请求，并通过轮询等待子进程的信号
        handle_request_and_wait_signal()
    else:
        #处理出错情况
        handle_fork_error()
```

其中执行fork()创建子进程的时候会有短暂的阻塞

​![image](https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116181340-b6hx6au.png)​

#### SAVE命令执行时的服务器状态

​`SAVE`​命令执行时，Redis服务器会被阻塞。

只有在服务器执行完`SAVE`​命令、重新开始接受命令请求之后，客户端发送的所有命令才会被处理。

#### BGSAVE命令执行时的服务器状态

因为BGSAVE命令的保存工作是由子进程执行的，所以在子进程创建RDB文件的过程中，Redis服务器仍然可以继续处理客户端的命令请求，但是，在`BGSAVE`命令执行期间，服务器处理`SAVE`、`BGSAVE`、`BGREWRITEAOF`三个命令的方式会和平时有所不同。

1. 在`BGSAVE`命令执行期间，客户端发送的`SAVE`命令会被服务器拒绝，服务器禁止`SAVE`​​命令和`BGSAVE`​​命令同时执行是为了避免父进程和子进程同时执行两个`rdbSave`​​调用，*防*止产生竞争条件
2. ​`BGSAVE`命令执行期间，客户端发送的`BGSAVE`命令会被服务器拒绝，因为同时执行两个`BGSAVE`​​命令也会产生竞争条件。
3. ​`BGREWRITEAOF`​和`BGSAVE`​两个命令不能同时执行

    1. 如果`BGSAVE`​命令正在执行，那么客户端发送的`BGREWRITEAOF`​命令会被延迟到`BGSAVE`​命令执行完毕之后执行
    2. 如果`BGREWRITEAOF`​命令正在执行，那么客户端发送的**`BGSAVE`**​命令会被服务器拒绝
4. 因为`BGREWRITEAOF`​和`BGSAVE`​两个命令的实际工作都由子进程执行，所以这两个命令在操作方面并没有什么冲突的地方，不能同时执行它们只是一个性能方面的考虑——并发出两个子进程，并且这两个子进程都同时执行大量的磁盘写入操作。

### RDB文件的载入

RDB文件的载入工作是在服务器启动时自动进行的，所以Redis没有专门用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件。

#### RDB文件载入时的服务器状态

服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止。

### 自动间隔性保存

因为`BGSAVE`不会阻塞主进程的特点，Redis允许用户通过设置服务器配置的`save`选项，让服务器每隔一段时间自动执行一次`BGSAVE`命令。

举例

```c

save 900 1
save 300 10
save 60 10000
```

只要满足以下三个条件中的任意一个，BGSAVE命令就会被执行

1. 服务器在900秒之内，对数据库进行了至少1次修改。
2. 服务器在300秒之内，对数据库进行了至少10次修改。
3. 服务器在60秒之内，对数据库进行了至少10000次修改。

#### 设置保存时间

当Redis服务器启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save选项，如果用户没有主动设置save选项，那么服务器会为save选项设置默认条件：

```c
save 900 1
save 300 10
save 60 10000
```

#### dirty计数器和lastsave属性

1. dirty计数器记录距离上一次成功执行`SAVE`​​命令或者`BGSAVE`​​命令之后，服务器对数据库状态（服务器中的所有数据库）进行了多少次修改（包括写入、删除、更新等操作）
2. lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间

#### 检查BGSAVE自动保存条件是否满足

Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。

```python
def serverCron():
    # ...
    #遍历所有保存条件
    for saveparam in server.saveparams:
        #计算距离上次执行保存操作有多少秒
        save_interval = unixtime_now()-server.lastsave
        #如果数据库状态的修改次数超过条件所设置的次数
        #并且距离上次保存的时间超过条件所设置的时间
        #那么执行保存操作
        if server.dirty ＞= saveparam.changes and 
           save_interval ＞ saveparam.seconds:
            BGSAVE()
    # ...
```

程序会遍历并检查saveparams数组中的所有保存条件，只要有任意一个条件被满足，那么服务器就会执行BGSAVE命令。

## 写时复制技术

> 执行 bgsave 过程中，由于是交给子进程来构建 RDB 文件，主线程还是可以继续工作的，此时主线程可以修改数据吗？
>
> 执行 bgsave 过程中，Redis 依然**可以继续处理操作命令**的，也就是数据是能被修改的。
>
> 那具体如何做到到呢？关键的技术就在于**写时复制技术（Copy-On-Write, COW）。**

> 补充：使用linux的时候，父子进程
>
> 父进程的数据，子进程可不可以看得到？
>
> 常规思想：进程是数据隔离的，
>
> 进阶思想：父进程其实可以让子进程看到数据
>
> linux中 export的环境变量，子进程的修改不会破坏父进程，父进程的修改也不会破坏子进程

执行`bgsave`​​​​命令时，会通过`fork()`​​​​创建子进程，**此时子进程和父进程是共享一片内存区域的** 因此创建子进程的时候，会复制父进程的页表，这个**页表记录着虚拟地址和物理地址映射关系**，而不会复制物理内存，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个 **。**

这样一来，子进程就共享了父进程的物理内存数据了，这样能够**节约物理内存资源**​，页表对应的页表项的属性会标记该物理内存的权限为**只读**。

不过，当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发**写保护中断**，这个写保护中断是由于违反权限导致的，然后操作系统会在「写保护中断处理函数」里进行**物理内存的复制**，并重新设置其内存映射关系，将父子进程的内存读写权限设置为**可读写**，最后才会对内存进行写操作

​![image](https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116160431-snb0bkk.png)​

**只有在发生修改内存数据的情况时，物理内存才会被复制一份。**

这样是为了防止 fork 创建子进程时，由于物理内存数据的复制时间过长而导致父进程长时间阻塞的问题。

​![image](https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116160458-hifyfmc.png)​

当然，操作系统复制父进程页表的时候，父进程也是阻塞中的，不过页表的大小相比实际的物理内存小很多，所以通常复制页表的过程是比较快的。

不过，如果父进程的内存数据非常大，那自然页表也会很大，这时父进程在通过 fork 创建子进程的时候，阻塞的时间也越久。

**所以，有两个阶段会导致阻塞父进程：**

1. 创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；
2. 创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长；

也就是说1.拷贝页表结构。2.复制物理内存 会阻塞

复制页表 虚拟地址 --- 只读

修改共享数据 --- 写时复制 --- 拷贝物理内存

**减少创建子进程时的性能损耗，从而加快创建子进程的速度，毕竟创建子进程的过程中，是会阻塞主线程的。** 

但是，如果主线程（父进程）要**修改共享数据里的某一块数据**（比如键值对 `A`​​​）时，就会发生写时复制，于是这块数据的**物理内存就会被复制一份（键值对 **​**`A'`** ​​​ **）** ，然后**主线程在这个数据副本（键值对 ** **`A'`**  **）进行修改操作**。与此同时，**bgsave 子进程可以继续把原来的数据（键值对 ** **`A`** **）写入到 RDB 文件**。

但是，bgsave 快照过程中，如果主线程修改了共享数据，**发生了写时复制后，RDB 快照保存的是原本的内存数据**，而主线程刚修改的数据，是没办法在这一时间写入 RDB 文件的，只能交由下一次的 bgsave 快照。

所以 Redis 在使用 bgsave 快照过程中，如果主线程修改了内存数据，不管是否是共享的内存数据，RDB 快照都无法写入主线程刚修改的数据，因为此时主线程（父进程）的内存数据和子进程的内存数据已经分离了，子进程写入到 RDB 文件的内存数据只能是原本的内存数据。

如果系统恰好在 RDB 快照文件创建完毕后崩溃了，那么 Redis 将会丢失主线程在快照期间修改的数据。

**无法保证实时数据落盘**

# AOF持久化

AOF持久化是通过保存Redis服务器所执行的**写命令**来记录数据库状态的。

​![image](https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116161120-j12y876.png)​

## 开启AOF持久化

在 Redis 中 AOF 持久化 功能默认是不开启的，需要我们修改 `redis.conf`​ 配置文件中的以下参数：

​![image](https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116161225-z4t8o3q.png)​

## AOF持久化过程

AOF持久化功能的实现可以分为**命令追加**、**文件写入**、**文件同步**三个步骤

> Redis是“写后”日志，Redis先执行命令，把数据写入内存，然后才记录日志。日志里记录的是Redis收到的每一条命令，这些命令是以文本形式保存。PS: 大多数的数据库采用的是写前日志（WAL），例如MySQL，通过写前日志和两阶段提交，实现数据和逻辑的一致性。

​![image](https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230413144927-rdjembx.png)​

### 命令追加

当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的**aof_buf缓冲区**的末尾：

```c
struct redisServer {
    // ...
    // AOF缓冲区
    sds aof_buf;
    // ...
};
```

**举例：**

```c
redis＞ SET KEY VALUE
OK
```

那么服务器在**执行这个SET命令之后**，会将以下协议[内容]()追加到aof_buf缓冲区的末尾

```c
*3\r\n$3\r\nSET\r\n$3\r\nKEY\r\n$5\r\nVALUE\r\n
```

* 「`*3`​​」表示当前命令有三个部分，每部分都是以「`$+数字`​​」开头，后面紧跟着具体的命令、键或值。
* 「`数字`​​」表示这部分中的命令、键或值一共有多少字节。例如，「`$3 set`​​」表示这部分有 3 个字节，也就是「`set`​​」命令这个字符串的长度。

写后日志

**Redis**​**先执行写操作再追加命令****的好处：**

1. **避免额外的检查开销**

    因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。

    而如果先执行写操作命令再记录日志的话，只有在该命令执行成功后，才将命令记录到 AOF 日志里，这样就不用额外的检查开销，保证记录在 AOF 日志里的命令都是可执行并且正确的。
2. **不会阻塞****当前写操作命令的执行**

    因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。

缺点：

1. 如果命令执行完成，写日志之前宕机了，会丢失数据 

    丢失的不多

### 文件写入和同步

#### 概念

在现在操作系统中，当用户调用write函数，将一些数据写入到文件的时候，操作系统通常会将写入的数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填、或者超过了指定的时限之后，才真正地将缓冲区中的数据写入到磁盘里面。

**优点：**

提高了效率

**缺点：**

写入数据具有安全问题，因为如果计算机发生停机，那么保存在内存缓冲区中里面的写入数据将会消失

**解决方案：**

系统提供了`fsync`和`fdatasync`两个同步函数，它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保写入数据的安全性。

#### 过程

在 Redis 中客户端向服务器发送相关写命令请求，这时服务器中有个用于处理这些命令的事件循环进程，对这些命令进行处理，并将相关信息处理的结果反馈给客户端，如："`OK`​​"，等。

同时，在这个期间，服务器中命令请求器会将相关写命令追加到 `aof_buf `​缓冲区和` aof_rewrite_buf `​重写缓冲区。

这个阶段服务器进程会处理这三个操作

​![image](https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116163259-b1mi258.png)​

1. 执行客户端的命令
2. 将执行后的写命令append入aof_buf中
3. 将执行后的写命令append到aof_rewrite_buf中

​![image](https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116163259-b1mi258.png)​

当进行 AOF持久化的时候，对于 aof_buf 中的数据需要写入并同步到 appendonly.aof 文件中

​![image](https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116164105-sa8u44c.png)​

##### 三种写回策略

是否将 aof_buf 缓冲区中内容写入AOF文件中，由 redis.conf 配置文件中的 appendfsync 设置的值来决定，通过 flushAppendFile 函数来进行相关操作。

```c
//事件轮询函数
def evenloop():
　　while True:
       ........
　　　　//是否将 aof_buf 缓冲区中的内容写入并同步到 appendonly.aof 文件中。
       flushAppendOnlyFile()
```

|appendfsync 选项的值|flushAppendOnlyFile 函数的行为|
| ----------------------| ----------------------------------------------------------------------------------------------------------------------------------------------------------|
|always|将 aof_buf 缓冲区中的所有内容写入并同步到 AOF 文件中（最安全，但性能差）|
|everysec|将 aof_buf 缓冲区中的所有内容写入并同步到 AOF 文件中，如果上次同步 AOF 文件的时间距离现在超过 1 秒钟，那么会再次对 AOF 文件进行同步。 （安全，性能较好）|
|no|将 aof_buf 缓冲区中的所有内容写入并同步到 AOF 文件中，但不对 AOF 文件进行同步，何时进行同步一般有操作系统来决定。（一般为 30 秒，不安全，性能最好）|

​![image](https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116164404-zs0e8xz.png)​

在**概念**中我们谈到

> 系统提供了`fsync`​和`fdatasync`​两个同步函数，它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保写入数据的安全性。

其实以上三种策略只是在控制 `fsync()`​​ 函数的调用时机

当应用程序向文件写入数据时，内核通常先将数据复制到内核缓冲区中(写入)，然后排入队列，然后由内核决定何时写入硬盘(同步)。

​![image](https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116164627-z913ra4.png)​

如果想要应用程序向文件写入数据后，能立马将数据同步到硬盘，就可以调用 `fsync()`​​ 函数，这样内核就会将内核缓冲区的数据直接写入到硬盘，[等到]()硬盘写操作完成后，该函数才会返回。

* Always 策略就是每次写入 AOF 文件数据后，就执行 fsync() 函数；
* Everysec 策略就会创建一个异步任务来执行 fsync() 函数；
* No 策略就是永不执行 fsync() 函数;

## AOF 重写机制

### 出现的问题

AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。

如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。

### AOF重写原理

Redis 为了避免 AOF 文件越写越大，提供了 **AOF 重写机制**，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。

AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录后，就将新的 AOF 文件替换掉现有的 AOF 文件。

相当于是用操作来对当前数据库中的数据进行快照

举例：

举个例子，在没有使用重写机制前，假设前后执行了「*set name xiaolin*」和「*set name xiaolincoding*」这两个命令的话，就会将这两个命令记录到 AOF 文件。

​![image](https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116165141-csa8gdn.png)​

但是**在使用重写机制后，就会读取 name 最新的 value（键值对） ，然后用一条 「set name xiaolincoding」命令记录到新的 AOF 文件**，之前的第一个命令就没有必要记录了，因为它属于「历史」命令，没有作用了。这样一来，一个键值对在重写日志中只用一条命令就行了。

### AOF后台重写过程

写入 AOF 日志的操作是在主进程中的，但是在触发 AOF 重写时，**比如当 AOF 文件大于 64M 时，就会对 AOF 文件进行重写**，这时需要读取所有缓存的键值对数据，并为每个键值对生成一条命令，然后将其写入到新的 AOF 文件，重写完后，就把现在的 AOF 文件替换掉。

这个过程其实是很耗时的，所以重写的操作不能放在主进程里。

所以，Redis 的​**重写 AOF 过程是由后台子进程 ** ***bgrewriteaof*** ** 来完成的**​，这么做可以达到两个好处：

1. 子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程
2. 子进程带有主进程的数据副本，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。实现了无锁

    而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。

主进程在通过 `fork`​ 系统调用生成 bgrewriteaof 子进程时，操作系统会把主进程的「**页表**」复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。

​![image](https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116160431-snb0bkk.png)​

这样一来，子进程就共享了父进程的物理内存数据了，这样能够**节约物理内存资源**，页表对应的页表项的属性会标记该物理内存的权限为**只读**。

不过，当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发​**写保护中断**​，这个写保护中断是由于违反权限导致的，然后操作系统会在「写保护中断处理函数」里进行​**物理内存的复制**​，并重新设置其内存映射关系，将父子进程的内存读写权限设置为​**可读写**​，最后才会对内存进行写操作，这个过程被称为「​**写时复制(**​***Copy On Write***​ **)** ​」。

触发**重写机制**后，主进程就会**创建重写 AOF 的子进程**，此时父子进程共享物理内存，重写子进程只会对这个内存进行只读，重写 AOF 子进程会读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志（新的 AOF 文件）。

但是子进程重写过程中，主进程依然可以正常处理命令。

如果此时​**主进程修改了已经存在 key-value，就会发生写时复制，注意这里只会复制主进程修改的物理内存数据，没修改物理内存还是与子进程共享的**​。

所以如果这个阶段修改的是一个 bigkey，也就是数据量比较大的 key-value 的时候，这时复制的物理内存数据的过程就会比较耗时，有阻塞主进程的风险。

还有个问题，重写 AOF 日志过程中，如果主进程修改了已经存在 key-value，此时这个 key-value 数据在子进程的内存数据就跟主进程的内存数据不一致了，这时要怎么办呢?

为了解决这种数据不一致问题，Redis 设置了一个 **AOF 重写缓冲区**，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。

在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会**同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」** 。

​![image](https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116171122-l2lv5mz.png)​

也就是说，在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:

* 执行客户端发来的命令；
* 将执行后的写命令追加到 「AOF 缓冲区」；
* 将执行后的写命令追加到 「AOF 重写缓冲区」；

当子进程完成 AOF 重写工作（*扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志*）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。

主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：

* 将 AOF 重写缓冲区中的所有内容**追加**到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；

  ‍
* 新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。

也就是说子进程进行重写后 父进程会对该aof文件进行矫正 把自己这段时间对数据的修改命令追加到aof文件末尾

**与RDB中BGSAVE写时复制技术的区别：**

1. BGSAVE快照过程中，如果主线程修改了共享数据，**发生了写时复制后，RDB 快照保存的是原本的内存数据**，而主线程刚修改的数据，是没办法在这一时间写入[ ]()RDB 文件的，只能交由下一次的 bgsave 快照。
2. AOF重写虽然会进行写时复制将主进程和子进程区分开，但是主进程会将**写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」** 。当子进程完成 AOF 重写工作后，主进程会将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致

### 优点

重写机制的妙处在于，尽管某个键值对被多条写命令反复修改，**最终也只需要根据这个「键值对」当前的最新状态，然后用一条命令去记录键值对**，代替之前记录这个键值对的多条命令，这样就减少了 AOF 文件中的命令数量。最后在重写工作完成后，将新的 AOF 文件覆盖现有的 AOF 文件

> 为什么重写 AOF 的时候，不直接复用现有的 AOF 文件，而是先写到新的 AOF 文件再覆盖过去？

因为​**如果 AOF 重写过程中失败了，现有的 AOF 文件就会造成******​，可能无法用于恢复使用。

所以 AOF 重写过程，先重写到新的 AOF 文件，重写失败的话，就直接删除这个文件就好，不会对现有的 AOF 文件造成影响。

# 混合持久化

## 问题

尽管 RDB 比 AOF 的数据恢复速度快，但是快照的频率不好把握：

* 如果频率太低，两次快照间一旦服务器发生宕机，就可能会比较多的数据丢失；
* 如果频率太高，频繁写入磁盘和创建子进程会带来额外的性能开销。

## 开启混合持久化

如果想要开启混合持久化功能，可以在 Redis 配置文件将下面这个配置项设置成 yes

```c
aof-use-rdb-preamble yes
```

混合持久化其实是对AOF持久化机制的一种优化，工作在 **AOF 日志重写过程**中。

当开启了混合持久化时，在 AOF 重写日志时，`fork` 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。

也就是说，使用了混合持久化，AOF 文件的**前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据**。

​![image](https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116172246-b5kv9im.png)​

优点：

1. 重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样**加载的时候速度会很快**。（aof加载数据没有rdb快）

2. 加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得**数据更少的丢失**。

# 对比两种持久化机制

## RDB和AOF优缺点

### RDB

1. 优点  

    * RDB快照是一个压缩过的非常紧凑的文件，保存着某个时间点的数据集，**适合做数据的备份**
    * 可以最大化Redis的性能，在保存RDB文件时，服务器进程只需fork一个子进程来完成RDB文件的创建，父进程不需要做IO操作
    * 与AOF相比，恢复大数据集的时候会更快
2. 缺点

    * RDB的数据安全性不如AOF，保存整个数据集的过程是比较繁重的，据配置可能要几分钟才快照一次，如果服务器宕机，那么就可能丢失几分钟的数据
    * Redis数据集较大时，fork的子进程要完成快照会比较耗CPU、耗时

### AOF 

1. 优点：

    * 数据更完整，安全性更高，秒级数据丢失（取决fsync策略，如果是everysec，最多丢失1秒的数据）
    * AOF文件是一个只进行追加的日志，且写入操作是以Redis协议的格式保存的，内容是可读的，适合误删紧急回复。

2. 缺点：

    * 对于相同的数据集，AOF文件的体积要大于RDB文件，数据恢复也会比较慢
    * 根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB。 不过在一般情况下， 每秒 fsync 的性能依然非常高

## 如何选择RDB和AOF

* 如果是数据不那么敏感，且可以从其他地方重新生成补回的，那么可以关闭持久化
* 如果是数据比较重要，不想再从其他地方获取，且可以承受数分钟的数据丢失，比如缓存等，那么可以只使用RDB
* 如果是用做内存数据库，要使用Redis的持久化，建议是RDB和AOF都开启，或者定期执行`bgsave`​做快照备份，RDB方式更适合做数据的备份，AOF可以保证数据不丢失。

‍

# 最终大总结

RDB和AOF都提供了开启子进程 这里用子进程的原因是？

避免多线程上下文开销 并且不需要保证锁

‍

RDB bgsave和 AOF bgrewriteaof 执行过程中的异同

1. 相同点

    因为都需要开启一个子进程 所以在发生写冲突时候会触发写保护中断 通过“写时复制技术”来保证
2. 不同点 

    rdb的bgsave是一个后台落盘的子进程

    aof的bgrewriteaof只是一个进行重写aof的子进程

‍
